import fs from 'fs';
import path, { resolve, dirname, extname, join } from 'path';
import { createFilter } from '@rollup/pluginutils';
import { transform, minify as minify$1 } from '@swc/core';
import createDeepMerge from '@fastify/deepmerge';
import { parseTsconfig, getTsconfig } from 'get-tsconfig';

const cache = new Map();
const getOptions = (cwd, tsconfig)=>{
    const cacheKey = `${cwd}:${tsconfig !== null && tsconfig !== void 0 ? tsconfig : 'undefined'}`;
    if (cache.has(cacheKey)) {
        var ref;
        return (ref = cache.get(cacheKey)) !== null && ref !== void 0 ? ref : {};
    }
    if (tsconfig && path.isAbsolute(tsconfig)) {
        var _compilerOptions;
        const compilerOptions = (_compilerOptions = parseTsconfig(tsconfig).compilerOptions) !== null && _compilerOptions !== void 0 ? _compilerOptions : {};
        cache.set(cacheKey, compilerOptions);
        return compilerOptions;
    }
    let result = getTsconfig(cwd, tsconfig || 'tsconfig.json');
    // Only fallback to `jsconfig.json` when tsconfig can not be resolved AND custom tsconfig filename is not provided
    if (!result && !tsconfig) {
        result = getTsconfig(cwd, 'jsconfig.json');
    }
    var _compilerOptions1;
    const compilerOptions1 = (_compilerOptions1 = result === null || result === void 0 ? void 0 : result.config.compilerOptions) !== null && _compilerOptions1 !== void 0 ? _compilerOptions1 : {};
    cache.set(cacheKey, compilerOptions1);
    return compilerOptions1;
};

const INCLUDE_REGEXP = /\.[mc]?[jt]sx?$/;
const EXCLUDE_REGEXP = /node_modules/;
const ACCEPTED_EXTENSIONS = [
    '.ts',
    '.tsx',
    '.mjs',
    '.js',
    '.cjs',
    '.jsx'
];
const deepmerge = createDeepMerge({
    all: true,
    mergeArray (options) {
        // overwrite instead of concatenating arrays
        return (target, source)=>options.clone(source);
    }
});
const fileExists = (path)=>{
    return fs.promises.access(path, fs.constants.F_OK).then(()=>true).catch(()=>false);
};
function swc(options = {}) {
    const filter = createFilter(options.include || INCLUDE_REGEXP, options.exclude || EXCLUDE_REGEXP);
    const extensions = options.extensions || ACCEPTED_EXTENSIONS;
    const resolveFile = async (resolved, index = false)=>{
        const fileWithoutExt = resolved.replace(INCLUDE_REGEXP, '');
        for (const ext of extensions){
            const file = index ? join(resolved, `index${ext}`) : `${fileWithoutExt}${ext}`;
            // We only check one file at a time, and we can return early
            // eslint-disable-next-line no-await-in-loop
            if (await fileExists(file)) return file;
        }
        return null;
    };
    return {
        name: 'swc',
        async resolveId (importee, importer) {
            // ignore IDs with null character, these belong to other plugins
            if (importee.startsWith('\0')) {
                return null;
            }
            if (importer && importee[0] === '.') {
                const resolved = resolve(importer ? dirname(importer) : process.cwd(), importee);
                let file = await resolveFile(resolved);
                if (file) return file;
                if (!file && await fileExists(resolved) && (await fs.promises.stat(resolved)).isDirectory()) {
                    file = await resolveFile(resolved, true);
                    if (file) return file;
                }
            }
        },
        async transform (code, id) {
            var ref;
            if (!filter(id)) {
                return null;
            }
            const ext = extname(id);
            if (!extensions.includes(ext)) return null;
            const isTypeScript = ext === '.ts' || ext === '.mts' || ext === '.cts' || ext === '.tsx';
            const isTsx = ext === '.tsx';
            const isJsx = ext === '.jsx';
            const tsconfigOptions = options.tsconfig === false ? {} : getOptions(dirname(id), options.tsconfig);
            // TODO: SWC is about to add "preserve" jsx
            // https://github.com/swc-project/swc/pull/5661
            // Respect "preserve" after swc adds the support
            const useReact17NewTransform = tsconfigOptions.jsx === 'react-jsx' || tsconfigOptions.jsx === 'react-jsxdev';
            const swcOptionsFromTsConfig = {
                jsc: {
                    externalHelpers: tsconfigOptions.importHelpers,
                    parser: {
                        syntax: isTypeScript ? 'typescript' : 'ecmascript',
                        tsx: isTypeScript ? isTsx : undefined,
                        jsx: !isTypeScript ? isJsx : undefined,
                        decorators: tsconfigOptions.experimentalDecorators
                    },
                    transform: {
                        decoratorMetadata: tsconfigOptions.emitDecoratorMetadata,
                        react: {
                            runtime: useReact17NewTransform ? 'automatic' : 'classic',
                            importSource: tsconfigOptions.jsxImportSource,
                            pragma: tsconfigOptions.jsxFactory,
                            pragmaFrag: tsconfigOptions.jsxFragmentFactory,
                            development: tsconfigOptions.jsx === 'react-jsxdev' ? true : undefined
                        }
                    },
                    target: (ref = tsconfigOptions.target) === null || ref === void 0 ? void 0 : ref.toLowerCase(),
                    baseUrl: tsconfigOptions.baseUrl,
                    paths: tsconfigOptions.paths
                }
            };
            const { filename: _1 , include: _2 , exclude: _3 , tsconfig: _4 , extensions: _5 , minify: _6 , ...restSwcOptions } = options;
            const swcOption = deepmerge(swcOptionsFromTsConfig, restSwcOptions, {
                jsc: {
                    minify: undefined // Disable minify on transform, do it on renderChunk
                },
                filename: id,
                minify: false // Disable minify on transform, do it on renderChunk
            });
            return transform(code, swcOption);
        },
        renderChunk (code) {
            var ref, ref1, ref2, ref3;
            if (options.minify || ((ref = options.jsc) === null || ref === void 0 ? void 0 : (ref1 = ref.minify) === null || ref1 === void 0 ? void 0 : ref1.mangle) || ((ref2 = options.jsc) === null || ref2 === void 0 ? void 0 : (ref3 = ref2.minify) === null || ref3 === void 0 ? void 0 : ref3.compress)) {
                var ref4;
                return minify$1(code, (ref4 = options.jsc) === null || ref4 === void 0 ? void 0 : ref4.minify);
            }
            return null;
        }
    };
}
function minify(options = {}) {
    return {
        name: 'swc-minify',
        renderChunk (code) {
            return minify$1(code, options);
        }
    };
}
function defineRollupSwcOption(option) {
    return option;
}
function defineRollupSwcMinifyOption(option) {
    return option;
}

export { swc as default, defineRollupSwcMinifyOption, defineRollupSwcOption, minify, swc };
